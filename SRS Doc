# **1. Introduction**
---
## **1.1 Purpose**
---
The purpose of this document is to describe the implementation details and objectives of our upcoming collaborative DJing app - Verge.

## **1.2 Intended Audiemce**
---
The audience of this document is our team members, including Kirstyn Fagnani, Kinjal Rele, Derrick Hood, and John Bergin, as well as our instructor for CSC 4351 - Professor John Martin. 
## **1.3 Intended Use**
---
This document will allow our team to align with the work that needs to be completed with this project. With this document, we intend to refer back to it and ensure we are on task and have completed the original scope. This includes items like the design, brainstorming of features, planning durations, and measuring what can be accomplished in the amount of time we have. We will use this document to guide the future of our product while staying aligned with our initial ideas. 
## **1.4 Scope**
---
Verge is a seamless collaborative DJ experience that lets listeners control the music. DJs can instantly accept and relinquish control of the mix without missing a beat. As a listener, you can request your favorite song, and the DJ will see it. Whether you are a professional DJ, a weekend hobbyist, or just someone who enjoys good tunes, Verge lets everyone play a part in the mix.
<br><br>
Some features that define our product:
- Create, browse, share, and listen to playlists. 
- Your playlist can be locked or unlocked. Totally up to you what playlist you want to make public.
- If you give access to another user, they can add songs to your playlists. This requires a passcode.
- If a DJ plays live (in-person or virtually), you can quickly scan their QR code to request songs.
- As a DJ, you can set a genre before you start mixing. Songs requested that do not match the vibe will be automatically denied.
<br><br>

Many apps on the market allow DJs to mix electronically, but we have found none that incorporate the experience we intend to. We intend to create a space where listeners can connect with their favorite DJs easily and where DJs can share their premade playlist or their music in real time. Think of a mix between Spotify, Twitch, and Social Media. We hope that Verge will allow DJs and Listeners to have a meaningful experience on both ends. 

## **1.5 Definitions and Acronyms**
--- 
The remainder of the document will use the following conventions:
- QR Code
  : Quick Response Code
  <br>

In addition:
- "Listeners" will refer to a user that listens to the DJs. This is the standard user in our application. 
- "DJs" will refer to a user that is offering their music services to the listeners.

# **2. Overall Description**
---
## **2.1 User Needs**
--- 
Verge attempts to solve four core user problems:
<br>

1. Listeners currently are not able to follow and connect with their favorite DJs on a single platform that will also let them know when the DJ has dropped a new fire mix or are live at an in-person event. 
2. At the same time, it is difficult for new and upcoming DJs to expand their marketability and increase their listening audience. While having the ability to grow - DJs will still be able to be in control of their mix choices. 
3. Currently, it is difficult for listeners to request songs at live events - you have to yell over loud crowds, be turned down with requesting music, make your way to the DJ in a sea of people, and so many more unfortunate situations.
 4. While Spotify allows you to share playlists with others, if the playlist is locked, the person it is shared with will not be able to add any music. There is no way around this other than making the said friend a contributor on the main user's end. We have worked around this with a passcode option. With the passcode shared with friends in a private playlist, they can add music and contribute to it.
 <br>

Our targeted users need an app that is more than watching a DJ live stream and more than listening to famous DJ's pre-recorded songs on a playlist. There are other ways to hear DJs mixes (Spotify, Twitch), but they do not offer a connection between DJs and their Listeners seamlessly. 

## **2.2 Assumptions and Dependencies**
--- 
This app makes 3 major assumptions:
<br>

1. That there is sufficient demand and interest to sustain an ecosystem of dog drivers and passengers. U4D will only be successful if a thriving marketplace for dog transport crops up.
2. That legal barriers to canine operation of motor vehicles will be lifted in the next 3-6 months, well before the app's development is complete.
3. That dogs will be sufficiently motivated by lucrative employment to learn how to drive and use smartphones.
<br>

Other major dependencies:
<br>
1. Our intent is to launch the app in the App Store and Google Play Store, which means that we have a hard dependency on Google and Apple's willingness to host our product. We do not anticipate this being a serious concern.
2. The cousin of our CFO is an engineer at Lyft, and to reduce development time, she has agreed to share all of Lyft's source code with us (clandestinely, of course). If Lyft becomes aware of this, or her employment is terminated for other reasons, development time will significantly increase as we are forced to come up with our own architecture and implementation.

# **3. System Features and Requirements**
---
## **3.1 Functional Requirements**
--- 
### **3.1.1 Login and Signup**
Description: A rider should be able to sign up for U4D using their existing phone number, social media, or paw print. They should be required to leave a credit card on file before proceeding to the app. 
<br>

Acceptance criteria:
- If visiting app for the first time, a modal should appear asking the user to sign up
- Modal should contain options to sign up via phone number, Google, or paw print.
- Confirmation text/email/treat should be sent to the user depending on their designated sign-in option
- Once user is confirmed, modal should transition to asking them for a credit card on file.
- Only valid CC #'s should be accepted.
- Once CC info is validated, modal should disappear and main view of app should be visible.

### **3.1.2 Request Ride**
Description: A rider should be able to request a ride from their current location, or from a custom location if necessary. The user should be shown a confirmation of where they will be picked up and asked to either approve that location or provide a different one. (This will ideally be accomplished by dragging a pin around a map.) 
<br>

Acceptance criteria:
- Main view of app should have a button in the center/bottom with the text "Request a ride"
- Once button is clicked, a modal should appear asking the user to enter a destination
- Destination entry screen should feature a search bar that users can look up most major addresses/locations with
- After destination is entered, modal should shift to confirming user location. The assumed location of the user should be displayed, and a button to confirm the location should be present.
- Start point entry screen should feature the same search bar as destination entry.
- Dragging along the start point entry screen should reposition the assumed user location.
- Pressing the confirm button should result in a request being sent for a driver.
- A message should appear informing the user that a ride has been requested.
- Once a driver has been found, app should notify user.

## **3.2 External Interface Requirements**
--- 
Go [here](https://www.figma.com/file/WU8gp8hLu8ApWYinHcOOta/Capstone-Project?node-id=0%3A1&t=H6EqYn86h7zY2Pk2-1) for visual specifications.
## **3.3 System Requirements**
--- 
1. App requires location services enabled on a smartphone so that real-time features are accessible.
2. Based on preliminary data volume estimates, app requires a 4G or better connection to run optimally.
3. Comparable apps require 50-100MB of phone storage available, and we expect U4D requirements to be in this range as well.

## **3.4 Nonfunctional Requirements**
---
1. App layout should be intuitive and feel responsive so we can retain users.
2. Real-time updates of rider and driver locations should refresh every 2s at most while app is open, and every 30s while app is closed, with animations used to "smooth" updates in the UI.
